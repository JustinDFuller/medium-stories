<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Let’s Compose Promises!</title><meta name="description" content="Today we’re going to combine two of the most useful tools that a JavaScript developer has in his or her tool belt. Promises and Function…"><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Let’s Compose Promises!</h1>
</header>
<section data-field="subtitle" class="p-summary">
Today we’re going to combine two of the most useful tools that a JavaScript developer has in his or her tool belt. Promises and Function…
</section>
<section data-field="body" class="e-content">
<section name="ca50" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c1c3" id="c1c3" class="graf graf--h3 graf--leading graf--title">Let’s Compose Promises!</h3><p name="2960" id="2960" class="graf graf--p graf-after--h3">Today we’re going to combine two of the most useful tools that a JavaScript developer has in his or her tool belt. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Promises</a> and <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" data-href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0" class="markup--anchor markup--p-anchor" target="_blank">Function Composition</a>.</p><figure name="7667" id="7667" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 650px; max-height: 606px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 93.2%;"></div><img class="graf-image" data-image-id="1*IhaDj8f_Orwoh4HVb6xZKQ.jpeg" data-width="650" data-height="606" src="https://cdn-images-1.medium.com/max/800/1*IhaDj8f_Orwoh4HVb6xZKQ.jpeg"></div><figcaption class="imageCaption">Please enjoy this barely related comic about Functional Programming :)</figcaption></figure><h4 name="167c" id="167c" class="graf graf--h4 graf-after--figure">Promises</h4><p name="229f" id="229f" class="graf graf--p graf-after--h4">The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Promise API</a> is a simple but powerful way to handle asynchronous operations. To create a promise you would type <code class="markup--code markup--p-code">new Promise()</code> and the only argument would be a callback function.</p><p name="cfa9" id="cfa9" class="graf graf--p graf-after--p">The callback function accepts two arguments: <code class="markup--code markup--p-code">resolve</code> and <code class="markup--code markup--p-code">reject</code>. When your asynchronous function finishes you call resolve with the result. If your asynchronous function throws an error you can call <code class="markup--code markup--p-code">reject</code> with that error. It looks like this:</p><pre name="bd9a" id="bd9a" class="graf graf--pre graf-after--p">const myPromise = new Promise((resolve, reject) =&gt; {<br>  setTimeout(() =&gt; {<br>    resolve(&#39;Hello World&#39;);<br>  }, 2000);<br>});</pre><pre name="4d55" id="4d55" class="graf graf--pre graf-after--pre">myPromise.then(res =&gt; console.log(res)); // &#39;Hello World&#39; is shown after 2 seconds.</pre><p name="5253" id="5253" class="graf graf--p graf-after--pre">We are able to access the result of <code class="markup--code markup--p-code">resolve</code> by calling <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Promise.prototype.then</a>, which receives a callback function that has whatever you called <code class="markup--code markup--p-code">resolve</code> with as its argument.</p><p name="e9b7" id="e9b7" class="graf graf--p graf-after--p">Sometimes a Promise will throw an error. We can’t use a traditional <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">try/catch</a> block in this scenario, because the error may be thrown at a later time. Instead we use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Promise.prototype.catch</a>. Just like <code class="markup--code markup--p-code">.then()</code> it receives a callback function. The difference is that it will receive whatever you pass to the <code class="markup--code markup--p-code">reject</code> argument.</p><p name="03e6" id="03e6" class="graf graf--p graf-after--p">Finally, we may want to do some cleanup. What do we use? You guessed it: <a href="https://developers.google.com/web/updates/2017/10/promise-finally" data-href="https://developers.google.com/web/updates/2017/10/promise-finally" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Promise.prototype.finally</a>. Finally accepts a callback function, but that callback accepts no arguments. You can count on this function to be called after your Promise chain is finished executing. At the time of this writing <code class="markup--code markup--p-code">finally</code> isn’t available everywhere. You can use it in the latest version of Chrome or in <a href="http://bluebirdjs.com/docs/api/finally.html" data-href="http://bluebirdjs.com/docs/api/finally.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Bluebird</a>.</p><h4 name="e40f" id="e40f" class="graf graf--h4 graf-after--p">Chaining Promises</h4><p name="59d0" id="59d0" class="graf graf--p graf-after--h4">When working with Promises you can chain them. This means when you have multiple asynchronous options in a row you can do them one after the other. It looks something like this:</p><pre name="9665" id="9665" class="graf graf--pre graf-after--p">// In this example Promise.resolve represents any async action that returns a promise.<br>new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 3000))<br>  .then(res =&gt; Promise.resolve(res + 10))<br>  .then(res =&gt; Promise.resolve(res + 10))<br>  .then(console.log)<br>  .catch(console.error)  <br>  .finally(() =&gt; console.log(&#39;All done!&#39;);<br>// After 3 seconds logs 30 <br>// Then it logs &#39;All done!&#39;</pre><p name="5384" id="5384" class="graf graf--p graf-after--pre">As you can see Promises can be chained so that asynchronous operations can happen almost as if they are synchronous.</p><p name="60f2" id="60f2" class="graf graf--p graf-after--p">We used <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Promise.resolve</a> to represent a function that returns a Promise. <code class="markup--code markup--p-code">Promise.resolve</code> wraps a value in a Promise.</p><p name="a933" id="a933" class="graf graf--p graf-after--p">This isn’t a bad way of working with Promises, but I think we can do better.</p><h4 name="7d4b" id="7d4b" class="graf graf--h4 graf-after--p">Composition</h4><p name="d420" id="d420" class="graf graf--p graf-after--h4">Function composition is simple, but can be hard to wrap your mind around at first. The entire point of composition is to allow you to string functions together. If we were to look at our last example, but with synchronous functions, it would look something like this:</p><pre name="9625" id="9625" class="graf graf--pre graf-after--p">const result = compose(<br>  res =&gt; res + 10,<br>  res =&gt; res + 10,<br>)(10);<br>console.log(result); // 10</pre><p name="7c0b" id="7c0b" class="graf graf--p graf-after--pre">We took the result of each function, passed it to the next function, and that was the result of the whole composed function.</p><p name="1908" id="1908" class="graf graf--p graf-after--p">That <code class="markup--code markup--p-code">compose</code> function isn’t assumed to be a global function, like <code class="markup--code markup--p-code">Promise</code> or <code class="markup--code markup--p-code">Promise.resolve</code> are. We’ll have to define it. To define compose we’d have something like this:</p><pre name="26de" id="26de" class="graf graf--pre graf-after--p">const compose = (...functions) =&gt; <br>  initialValue =&gt;<br>    functions.reduceRight(<br>      (sum, fn) =&gt; fn(sum),<br>      initialValue,<br>    );</pre><p name="2e6f" id="2e6f" class="graf graf--p graf-after--pre">So.. what exactly is going on here? Let me walk you thought it step by step. This can be confusing, particularly if you aren’t familiar with a recent update to JavaScript known as <a href="http://es6-features.org" data-href="http://es6-features.org" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ES6</a>.</p><p name="28fb" id="28fb" class="graf graf--p graf-after--p">First we accept any amount of functions. Then we use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">spread operator </a>to gather all of those functions into a single array.</p><p name="2cb8" id="2cb8" class="graf graf--p graf-after--p">Next we accept the initial value that our compose function will use as it’s initial argument.</p><p name="7fc1" id="7fc1" class="graf graf--p graf-after--p">Once we have that initial value we begin calling each function from right to left (or bottom to top if you look at the example above). We use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Array.prototype.reduceRight</a> to make sure that the functions are called in this order. If you’re familiar with how <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Array.prototype.reduce</a> works then you’re already familiar with reduceRight, you just may not know it! <code class="markup--code markup--p-code">reduceRight</code> is reduce, but it works backwards.</p><p name="0691" id="0691" class="graf graf--p graf-after--p">The Array reduce and reduceRight methods iterate through an array, and at each index in the array a callback is called. That callback receives two arguments. A sum, and the value at the current index of the array.</p><p name="bbeb" id="bbeb" class="graf graf--p graf-after--p">In our case the value at the current index is a function. The sum is the <code class="markup--code markup--p-code">initialValue</code> for the first function in the array. After that the sum is the result of the previous function that has been called with the results of the function before it.</p><p name="925c" id="925c" class="graf graf--p graf-after--p">So now we hopefully see the power of Promises, the convenience and clarity of composition. What happens when we put them together?</p><h4 name="5e9d" id="5e9d" class="graf graf--h4 graf-after--p">Composing Promises</h4><p name="36f8" id="36f8" class="graf graf--p graf-after--h4">You might wonder why we can’t just compose Promises with the <code class="markup--code markup--p-code">compose</code> function that we just created. The problem is that we access that value through <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Promise.then</a>. So unless each of our functions unwraps it’s arguments like:</p><pre name="94c5" id="94c5" class="graf graf--pre graf-after--p">function myComposedFunction(argument) {<br>  argument.then(() =&gt; {<br>    // actual content of myComposedFunction goes here<br>  });<br>}</pre><p name="8c03" id="8c03" class="graf graf--p graf-after--pre">Then the function’s argument won’t be what it expects. Plus there’s another problem. Now <code class="markup--code markup--p-code">myComposedFunction</code> will only work with Promises! We can solve that problem rather simply.</p><pre name="dedf" id="dedf" class="graf graf--pre graf-after--p">function myComposedFunction(argument) {<br>  Promise.resolve(argument).then(() =&gt; {<br>    // actual content of myComposedFunction goes here<br>  });<br>}</pre><p name="0110" id="0110" class="graf graf--p graf-after--pre">But this seems like a lot of <a href="https://en.wikipedia.org/wiki/Boilerplate_code" data-href="https://en.wikipedia.org/wiki/Boilerplate_code" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">boilerplate</a>. Particularly if this is supposed to be a simple function. Maybe it just does: <code class="markup--code markup--p-code">return argument + 10;</code> we’ve just turned a very simple function into a very complicated one.</p><p name="85c3" id="85c3" class="graf graf--p graf-after--p">A much better way is to handle this within the <code class="markup--code markup--p-code">compose</code> function itself.</p><pre name="69aa" id="69aa" class="graf graf--pre graf-after--p">const composePromise = (...functions) =&gt;<br>  initialValue =&gt;<br>    functions.reduceRight(<br>      (sum, fn) =&gt; Promise.resolve(sum).then(fn),<br>      initialValue<br>    );</pre><p name="0675" id="0675" class="graf graf--p graf-after--pre">This <code class="markup--code markup--p-code">composePromise</code> function works exactly the same as our <code class="markup--code markup--p-code">compose</code> function earlier, with one major difference. It accepts Promises, and returns a Promise. You can use it like this:</p><pre name="cd4c" id="cd4c" class="graf graf--pre graf-after--p">const add100ToNumberString = composePromise(<br>  console.log,<br>  res =&gt; res.toString(),<br>  res =&gt; Promise.resolve(res + 100),<br>  res =&gt; Promise.resolve(Number(res)),<br>);</pre><pre name="a56d" id="a56d" class="graf graf--pre graf-after--pre">add100ToNumberString(new Promise(resolve =&gt; {<br>  setTimeout(() =&gt; {<br>    resolve(&#39;400&#39;);<br>  }, 2000);<br>})); <br>// Eventually prints out &#39;500&#39; after 2 seconds</pre><p name="2725" id="2725" class="graf graf--p graf-after--pre">You can continue to chain because the result of <code class="markup--code markup--p-code">add100ToNumberString</code> is a Promise. You can use <code class="markup--code markup--p-code">.catch()</code> and <code class="markup--code markup--p-code">.finally()</code> If needed as well!</p><h4 name="4f31" id="4f31" class="graf graf--h4 graf-after--p">Try it yourself!</h4><p name="5117" id="5117" class="graf graf--p graf-after--h4">Below I’ve embedded a <a href="https://codepen.io/" data-href="https://codepen.io/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">CodePen</a> playground with all this code in it so that you can try it out for yourself! Open up the console to see the results.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="0595" id="0595" class="graf graf--figure graf--iframe graf--layoutOutsetCenter graf-after--p graf--trailing"><iframe src="https://codepen.io/Iamjfu/embed/preview/XzaegE?height=600&amp;slug-hash=XzaegE&amp;default-tabs=js,result&amp;host=https://codepen.io&amp;embed-version=2" width="1000" height="750" frameborder="0" scrolling="no"></iframe></figure></div></div></section><section name="878c" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="f753" id="f753" class="graf graf--p graf--leading graf--trailing">Thanks for reading! Stay tuned for more functional programming posts!</p></div></div></section>
</section>
<footer><p class="p-tags">Tagged in <a href="https://medium.com/tag/javascript" class="p-tag">JavaScript</a>, <a href="https://medium.com/tag/programming" class="p-tag">Programming</a>, <a href="https://medium.com/tag/functional-programming" class="p-tag">Functional Programming</a>, <a href="https://medium.com/tag/es6" class="p-tag">ES6</a>, <a href="https://medium.com/tag/lets-compose-promises" class="p-tag">Lets Compose Promises</a></p><p>By <a href="https://medium.com/@justindanielfuller" class="p-author h-card">Justin Fuller</a> on <a href="https://medium.com/p/309a63225f8a"><time class="dt-published" datetime="2017-11-13T23:36:42.537Z">November 13, 2017</time></a>.</p><p><a href="https://medium.com/@justindanielfuller/lets-compose-promises-309a63225f8a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 16, 2018.</p></footer></article>

</body></html>