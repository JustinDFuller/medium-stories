<article class="h-entry">
  <header>
  <h1 class="p-name">Refactoring — oops, I’ve been doing it backwards.</h1>
  </header>
  <section data-field="subtitle" class="p-summary">
  Welcome to my intervention. I’m a refactoring addict and I’m not afraid to admit it, but there’s only one problem: I’ve been doing it…
  </section>
  <section data-field="body" class="e-content">
  <section name="ec96" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="f7f8" id="f7f8" class="graf graf--h3 graf--leading graf--title">Refactoring — oops, I’ve been doing it backwards.</h3><p name="5b06" id="5b06" class="graf graf--p graf-after--h3">Welcome to my intervention. I’m a refactoring addict and I’m not afraid to admit it, but there’s only one problem: I’ve been doing it backwards. You see, what I’ve been doing could be more accurately described as premature code abstraction.</p><figure name="bc31" id="bc31" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder"><img class="graf-image" data-image-id="1*oCtk28IdNdpjnyMGiRsfLA.jpeg" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*oCtk28IdNdpjnyMGiRsfLA.jpeg"></div></figure><p name="2c52" id="2c52" class="graf graf--p graf-after--figure">We all know about refactoring. If you’ve read even a single programming book, or if you spend much time on Medium, you’ll have heard all about it. It’s an important concept that keeps code understandable, maintainable, and extensible.</p><p name="9210" id="9210" class="graf graf--p graf-after--p">At least that’s what everyone tells me.</p><p name="4d6f" id="4d6f" class="graf graf--p graf-after--p">So why has refactoring not been accomplishing what I was hoping?</p><p name="a624" id="a624" class="graf graf--p graf-after--p">As I wrote my most recent library, I took some time to reflect on the evolution of my code. I realized that before I had a fully working product and before I had an ideal output in my unit tests, I had refactored my code into interfaces that I wasn’t even sure I would need. I had moved code around, made it extensible, made it reusable, but why? Was that code going to give me the final output I needed? I didn’t know yet.</p><p name="a28f" id="a28f" class="graf graf--p graf-after--p">Everything worked out in the end, but was my code more complicated than it needed to be? I believe so.</p><h4 name="85f4" id="85f4" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Principles Over Purpose</strong></h4><p name="2518" id="2518" class="graf graf--p graf-after--h4">Have you heard of <a href="https://en.wikipedia.org/wiki/SOLID" data-href="https://en.wikipedia.org/wiki/SOLID" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">SOLID</a> principles? I try to follow them closely. Every function that I write aims to have <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" data-href="https://en.wikipedia.org/wiki/Single_responsibility_principle" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a single responsibility</a>. My classes and factories aim to be <a href="https://en.wikipedia.org/wiki/Open/closed_principle" data-href="https://en.wikipedia.org/wiki/Open/closed_principle" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">open for extension while discouraging modification</a>. I also try not to depend directly on too many things, so instead, <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" data-href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">I accept dependencies as arguments</a> in functions and classes.</p><p name="c132" id="c132" class="graf graf--p graf-after--p">Does that like a recipe for good code? I think it does. The problem occurs when my code focuses on being SOLID, or <a href="https://en.wikipedia.org/wiki/Pure_function" data-href="https://en.wikipedia.org/wiki/Pure_function" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">pure</a>, rather than on accomplishing what it was born to do. The problem occurs when I put principles over purpose.</p><p name="0b13" id="0b13" class="graf graf--p graf-after--p">For example, I’ve been so focused on making sure my <a href="https://medium.freecodecamp.org/how-writing-tests-can-make-you-a-faster-and-more-productive-developer-f3ad978e3872?source=your_stories_page---------------------------&amp;gi=ee61e8c93f22" data-href="https://medium.freecodecamp.org/how-writing-tests-can-make-you-a-faster-and-more-productive-developer-f3ad978e3872?source=your_stories_page---------------------------&amp;gi=ee61e8c93f22" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">unit tests have no expensive IO</a> (input and output). I’ve occasionally had to go back and fix code that was wrong due to my incorrectly mocked dependencies.</p><p name="83a9" id="83a9" class="graf graf--p graf-after--p">So, what’s the solution?</p><p name="7e2a" id="7e2a" class="graf graf--p graf-after--p">Remember that reflection I mentioned earlier? It reminded me of the mantra, “<a href="http://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast" data-href="http://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Make it work, make it right, make it fast.</a>” I’ve realized I’ve been going out of order. I’ve been making it right, making it fast, then making it work!</p><h4 name="e21e" id="e21e" class="graf graf--h4 graf-after--p">Make It Work</h4><p name="44e4" id="44e4" class="graf graf--p graf-after--h4">As I’ve begun to write more it has become clear that good writing doesn’t just happen. First I have to get all my thoughts down on the page. I have to see where my thoughts take me. Then I must shape them into some sort of semi-coherent and non-rambling version of what just spilled out.</p><p name="1391" id="1391" class="graf graf--p graf-after--p">The same thing can happen with code.</p><p name="0b8a" id="0b8a" class="graf graf--p graf-after--p">Get it all out there into that function. At first don’t worry <em class="markup--em markup--p-em">too</em> much about naming, single responsibility, or being extensible — you’ll address that once your function is working. To be clear, you won’t be writing your whole application like this, just one small piece.</p><p name="e023" id="e023" class="graf graf--p graf-after--p">Once you’ve got the output you are looking for (you’ve got unit tests to prove that the code is correct, right?) begin refactoring, but don’t go too far too fast! For now, stick with refactoring strategies that are in the category of proper naming, functions doing only one thing, and the avoidance of mutation; don’t immediately start making extensible or reusable classes and factories until you have identified a repeating pattern.</p><p name="bf9b" id="bf9b" class="graf graf--p graf-after--p">At this point, it makes sense to use any refactoring that can stand on its own merit. This means refactoring with the purpose of the code being understood, or the code being reliable.</p><p name="54f2" id="54f2" class="graf graf--p graf-after--p">Consider postponing refactoring with patterns that are only useful in certain scenarios.</p><p name="1829" id="1829" class="graf graf--p graf-after--p">You’ll want to save those until you have a reason.</p><h4 name="68ba" id="68ba" class="graf graf--h4 graf-after--p">Have A Reason</h4><p name="08c9" id="08c9" class="graf graf--p graf-after--h4">Having SOLID code is not a reason. Having functional or pure code is not a reason.</p><p name="c5ba" id="c5ba" class="graf graf--p graf-after--p">Why do we make our code extensible? So that similar, but not exactly the same, functionality can branch off of base logic.</p><p name="a1e2" id="a1e2" class="graf graf--p graf-after--p">Why do we invert dependencies? So that the business logic can be used by multiple implementations.</p><p name="cf30" id="cf30" class="graf graf--p graf-after--p">Hopefully, you see where I am going with this. Some refactoring stands on its own. For example, refactoring the name of a variable to become more accurate will always make sense. Its merit is inherent. Refactoring a function to be pure usually makes sense because side-effects can cause unforeseen issues. Those are reasons.</p><p name="1872" id="1872" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“It’s best practice to use dependency inversion” is not a reason. “Good code is extensible” is not a reason. What if I only have a couple of never-changing dependencies? Do I still need dependency inversion? Not yet. What if nothing needs to extend my code and I have no plans for anything to do so? Should my code increase its complexity just to check off this box? No!</p><p name="1bd6" id="1bd6" class="graf graf--p graf-after--p">Take a look at the following example.</p><figure name="8c88" id="8c88" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/JustinDFuller/922e73aa725be331abdda7ff1ac6982b.js"></script></figure><p name="246e" id="246e" class="graf graf--p graf-after--figure">Which do you prefer? Which do you naturally tend to write first? Of course, the <code class="markup--code markup--p-code">User</code> class is far more extensible because it can handle more than just name and email. It can also be extended by a child class, maybe a <code class="markup--code markup--p-code">SuperUser</code>, that will have many more methods but still uses the classic <code class="markup--code markup--p-code">get()</code> and <code class="markup--code markup--p-code">set()</code> methods.</p><p name="3294" id="3294" class="graf graf--p graf-after--p">Still, that User class may be complete overkill, and now your code is more complicated than it will ever need to be.</p><p name="e4e3" id="e4e3" class="graf graf--p graf-after--p">My advice is to stick with the simplest possible pattern.</p><h4 name="f68a" id="f68a" class="graf graf--h4 graf-after--p">Order Of Complexity</h4><p name="72dc" id="72dc" class="graf graf--p graf-after--h4">And now, if you’ll allow it, I’m going to make something up! I call it the order of complexity and it helps me when I make refactoring decisions. It looks like this:</p><ul class="postList"><li name="3192" id="3192" class="graf graf--li graf-after--p"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Constant Variable</a></li><li name="e793" id="e793" class="graf graf--li graf-after--li"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Mutable Variable</a></li><li name="33af" id="33af" class="graf graf--li graf-after--li">Collection (Object, Array)</li><li name="8e9e" id="8e9e" class="graf graf--li graf-after--li">Function</li><li name="6bb1" id="6bb1" class="graf graf--li graf-after--li">Function with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Closure</a></li><li name="c2cc" id="c2cc" class="graf graf--li graf-after--li">Factory (A function that returns a collection)</li><li name="8e80" id="8e80" class="graf graf--li graf-after--li">Class</li></ul><p name="e4d3" id="e4d3" class="graf graf--p graf-after--li">Whenever I decide how to organize functionality, I refer to the list. I choose the highest possible choice that will suffice for my implementation. I don’t choose again until it simply will not work. Sometimes performance will affect this choice, but not often.</p><p name="deba" id="deba" class="graf graf--p graf-after--p">Usually, I find that I’ll put something in an object instead of a simpler constant variable. Or I created a factory when I only require a function.</p><p name="6243" id="6243" class="graf graf--p graf-after--p">This list keeps me grounded. It prevents me from prematurely refactoring.</p><h4 name="4de3" id="4de3" class="graf graf--h4 graf-after--p">Balance</h4><p name="bfe0" id="bfe0" class="graf graf--p graf-after--h4">I recently heard that if you say in a meeting, “it’s really all just about finding the right balance,” everyone will nod their head at your meaningless comment, like you’ve said something profound. I’ve got to give it a try soon.</p><p name="b6d9" id="b6d9" class="graf graf--p graf-after--p">Here, though, I think balance is important. As programmers we have to balance code quality, performance, maintainability, with the good old-fashioned need to get things done.</p><p name="4b37" id="4b37" class="graf graf--p graf-after--p">We have to be vigilant and make sure both needs stay in their correct place. Our code can’t be maintainable if it doesn’t work correctly. On the other hand, it’s hard to make bad code work correctly.</p><p name="cde4" id="cde4" class="graf graf--p graf-after--p">Still, code may be refactored, but what if it’s been refactored past the point of what is useful? These are important questions to keep in mind.</p><p name="1fd8" id="1fd8" class="graf graf--p graf-after--p graf--trailing">Next time you write your code, please, refactor! But also, maybe… don’t?</p></div></div></section><section name="6a2b" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="0d24" id="0d24" class="graf graf--p graf--leading">Hi, I’m Justin Fuller. I’m so glad you read my post! I need to let you know that everything I’ve written here is my own opinion and is not intended to represent my employer in any way. All code samples are my own and are completely unrelated to my employer.</p><p name="d552" id="d552" class="graf graf--p graf-after--p graf--trailing">I’d also love to hear from you, please feel free to connect with me on <a href="https://www.linkedin.com/in/justin-fuller-8726b2b1/" data-href="https://www.linkedin.com/in/justin-fuller-8726b2b1/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">LinkedIn</a>, <a href="https://github.com/justindfuller" data-href="https://github.com/justindfuller" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Github</a>, or <a href="https://medium.com/@justindanielfuller" data-href="https://medium.com/@justindanielfuller" class="markup--anchor markup--p-anchor" target="_blank">Medium</a>. Thanks again for reading!</p></div></div></section>
  </section>
  <footer><p>By <a href="https://medium.com/@justindanielfuller" class="p-author h-card">Justin Fuller</a> on <a href="https://medium.com/p/55eed503ccd0"><time class="dt-published" datetime="2019-01-24T17:43:21.956Z">January 24, 2019</time></a>.</p><p><a href="https://medium.com/@justindanielfuller/refactoring-oops-ive-been-doing-it-backwards-55eed503ccd0" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 27, 2019.</p></footer></article>