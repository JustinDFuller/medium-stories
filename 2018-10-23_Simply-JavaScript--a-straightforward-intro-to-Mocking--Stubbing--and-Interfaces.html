<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Simply JavaScript: a straightforward intro to Mocking, Stubbing, and Interfaces</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Simply JavaScript: a straightforward intro to Mocking, Stubbing, and Interfaces</h1>
</header>
<section data-field="subtitle" class="p-summary">
I like to think that I’m a simple guy, I like simple things. So whenever I sense complexity, my first reaction is to wonder if I can make…
</section>
<section data-field="body" class="e-content">
<section name="2dca" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3b3d" id="3b3d" class="graf graf--h3 graf--leading graf--title">Simply JavaScript: a straightforward intro to Mocking, Stubbing, and Interfaces</h3><p name="836f" id="836f" class="graf graf--p graf-after--h3">I like to think that I’m a simple guy, I like simple things. So whenever I sense complexity, my first reaction is to wonder if I can make things easier.</p><p name="4de7" id="4de7" class="graf graf--p graf-after--p">Before I transitioned to software development, I spent time as a sound engineer. I was recording bands and mixing live shows. I was even recording and mixing live shows for broadcast. During that time I talked with too many people who would always attempt to solve problems by purchasing some expensive, more complex equipment. Sadly the return on investment never seemed to be all it promised.</p><p name="a093" id="a093" class="graf graf--p graf-after--p">Instead of buying into the “more expensive, more complex is better” philosophy, I spent every evening learning the basics. I focused on the fundamental skills. I learned how to use an equalizer to make a voice sound natural. I learned how to use a compressor to soften quick and loud sounds or to beef up thin sounds. It turned out that the return on investment for those hours was more than I ever hoped for!</p><p name="430a" id="430a" class="graf graf--p graf-after--p">I ended up favoring the simplest tools and I was very happy with the work I produced.</p><p name="163e" id="163e" class="graf graf--p graf-after--p">I believe the same principle can be applied to almost every aspect of life — finances, parenting, even software engineering.</p><p name="6a74" id="6a74" class="graf graf--p graf-after--p">As people, we naturally tend to look for flashy, popular solutions that promise to solve all of our problems (or at least to perfectly solve a single problem). We are misguided to these complex solutions. We’ve created complicated problems by not properly understanding the fundamentals of whatever we’re struggling with.</p><figure name="1cc3" id="1cc3" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 500px; max-height: 261px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 52.2%;"></div><img class="graf-image" data-image-id="1*ZGXN6OAic_qErH80qjrTTA.jpeg" data-width="500" data-height="261" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*ZGXN6OAic_qErH80qjrTTA.jpeg"></div></figure><h3 name="4aa4" id="4aa4" class="graf graf--h3 graf-after--figure">JavaScript Basics</h3><p name="f3ff" id="f3ff" class="graf graf--p graf-after--h3">We’ll be looking at basic programming concepts and how they can be applied to JavaScript. The goal here is to have code that is simpler, more flexible, easier to understand, and easier to test.</p><p name="3617" id="3617" class="graf graf--p graf-after--p">First, before introducing interfaces, I’d like to talk about a problem.</p><h4 name="d73a" id="d73a" class="graf graf--h4 graf-after--p">Mocking, stubbing, and mutating</h4><p name="a2f0" id="a2f0" class="graf graf--p graf-after--h4">Recently I was writing code that read files from the file system. The code worked great. In order to test it, I had to use a library that would stop my code from reading from the file system. My tests would have been too slow if I had let it actually do that. Plus I needed to simulate scenarios that would have been complicated to implement with the actual file system.</p><p name="e734" id="e734" class="graf graf--p graf-after--p">Historically I would have used a library like <a href="https://www.npmjs.com/package/proxyquire" data-href="https://www.npmjs.com/package/proxyquire" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Proxyquire</a> or <a href="https://www.npmjs.com/package/sinon" data-href="https://www.npmjs.com/package/sinon" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Sinon</a>. Proxyquire allows you to override the imports of a file. Sinon allows you to mutate methods on an object. You can use either or both of these to make your code easier to test. Although it would be better to use just one.</p><p name="3146" id="3146" class="graf graf--p graf-after--p">As an example, let’s pretend you have a module called “a”. Let’s also say that module “a” imports module “b”. Proxyquire works by importing module “a” and overwriting the exports of module “b”. It won’t affect other imports of module “b” elsewhere. Sinon works by mutating the exports of module “b”. It will affect every place that imports module “b”, so you must remember to restore it when you are done.</p><figure name="bd33" id="bd33" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/JustinDFuller/1a69d16489b2665a56f5efa7a4f3bc65.js"></script></figure><h4 name="a51d" id="a51d" class="graf graf--h4 graf-after--figure">Why are stubs bad?</h4><p name="43a0" id="43a0" class="graf graf--p graf-after--h4">Neither of these options is great because they involve mutation. In software development, we want to avoid mutation when possible. because mutation leads to a decrease in predictability across an application.</p><p name="0a67" id="0a67" class="graf graf--p graf-after--p">One small mutation never seems like a big deal. But when there are many small mutations it becomes difficult to track which function is changing what value and when each mutation is being done.</p><p name="d758" id="d758" class="graf graf--p graf-after--p">There’s also the nuisance of lock-in. Both sinon and proxyquire will require you to update your tests if you change your file system library from <code class="markup--code markup--p-code">fs</code> to <code class="markup--code markup--p-code">fs-extra-promise</code>. In both cases, you’ll still be using the function <code class="markup--code markup--p-code">readFileAsync</code>. However, sinon and proxyquire will keep on trying to override <code class="markup--code markup--p-code">fs.readFile</code>.</p><h3 name="4fdd" id="4fdd" class="graf graf--h3 graf-after--p">What are the alternatives?</h3><p name="9c84" id="9c84" class="graf graf--p graf-after--h3">To solve this problem I followed a principle called <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" data-href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Dependency Inversion</a>. Instead of my module creating its own dependencies, it will expect to be given its dependencies. This produces modules that are both easier to test and more flexible. They can also be made to work with many implementations of the same dependencies.</p><figure name="230e" id="230e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/JustinDFuller/ad6218cac91c543d9de50d30cd57340f.js"></script></figure><p name="6c40" id="6c40" class="graf graf--p graf-after--figure">Not only have precious lines been saved in our code, but there is also no more worrisome mutation happening! The module will now accept <code class="markup--code markup--p-code">readFileAsync</code> rather than creating that function itself. The module is better because it’s more focused and has fewer responsibilities.</p><h4 name="e6cf" id="e6cf" class="graf graf--h4 graf-after--p">Where does the dependency go?</h4><p name="7654" id="7654" class="graf graf--p graf-after--h4">The dependencies have to be imported somewhere. In an application that follows dependency inversion, you should move the dependencies as far “out” as you can. Preferably you’d import them one time at the entry point of the application.</p><figure name="a7d8" id="a7d8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/JustinDFuller/0aea46495d06912acacc1508c3ecbcfe.js"></script></figure><p name="7aad" id="7aad" class="graf graf--p graf-after--figure">In the example, you saw that the dependencies were moved to the entry point of the application. Everything except <code class="markup--code markup--p-code">index.js</code> accepted an interface. This causes the application to be flexible, easy to change, and easy to test.</p><h3 name="5f91" id="5f91" class="graf graf--h3 graf-after--p">What else can Dependency Inversion do?</h3><p name="06a6" id="06a6" class="graf graf--p graf-after--h3">Now that you’ve fallen in love with dependency inversion I’d like to introduce you to some more of its power.</p><p name="bc65" id="bc65" class="graf graf--p graf-after--p">When your module accepts an interface, you can use that module with multiple implementations of that interface. This is a scenario where the libraries <a href="https://www.typescriptlang.org/" data-href="https://www.typescriptlang.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">TypeScript</a> and <a href="https://flow.org/" data-href="https://flow.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Flow</a> can be useful. They’ll check that you’ve provided the correct interface.</p><p name="4ed0" id="4ed0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">An interface is simply a collection of methods and properties</strong>. So by saying that a module accepts an interface, I am really saying that a module accepts an object that implements a set of methods and properties. The expectation is that the interfaces implement different functionality in a similar way.</p><p name="8dd3" id="8dd3" class="graf graf--p graf-after--p">A common interface you might know is the React component interface. In TypeScript it might look like this:</p><figure name="8ecc" id="8ecc" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/JustinDFuller/9aae67d963c92babfccd9aec5f1469c8.js"></script></figure><p name="b879" id="b879" class="graf graf--p graf-after--figure">Please don’t despair if you didn’t understand everything in that interface. The point is that a React Component has a predictable set of methods and properties that can be used to make many different components.</p><p name="ad5b" id="ad5b" class="graf graf--p graf-after--p">We are now beginning to venture into the territory of the<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" data-href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Open-Closed Principle</a>. It states that our software should be open for extension but closed for modification. This may sound very familiar to you if you’ve been building software with frameworks like <a href="https://angularjs.org/" data-href="https://angularjs.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Angular</a>, or <a href="https://reactjs.org/" data-href="https://reactjs.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">React</a>. They provide a common interface that you extend to build your software.</p><p name="ee60" id="ee60" class="graf graf--p graf-after--p">Now, instead of relying on third-party interfaces for everything, you can begin to rely on your own internal interfaces to create your own software.</p><p name="6ee5" id="6ee5" class="graf graf--p graf-after--p">If you are writing a CRUD (create, read, update, delete) application, you can create an interface that provides the building blocks for your actions. Your modules can extend that interface to implement the business logic and use-cases.</p><p name="c011" id="c011" class="graf graf--p graf-after--p">If you are writing an application that performs tasks, you can build a task interface that provides the building blocks for different tasks. Each task can accept that task interface and extend it.</p><p name="c0c6" id="c0c6" class="graf graf--p graf-after--p">Dependency inversion and the Open-Closed principle allow you to write more reusable, testable, and predictable software. You’ll no longer have a jumbled mess of spaghetti code. Instead, you’ll have a uniform group of modules that follow the same pattern.</p><h4 name="ef96" id="ef96" class="graf graf--h4 graf-after--p">Many Implementations</h4><p name="260a" id="260a" class="graf graf--p graf-after--h4">There’s one more benefit to accepting an interface. You can implement that interface in many different ways.</p><p name="c1eb" id="c1eb" class="graf graf--p graf-after--p">Here’s my favorite example of this. Imagine that you have an interface for a CRUD application. You could have one interface that implements the database storage. This is great, but what if the database reads or writes become slow? You could also write a faster implementation that uses <a href="https://redis.io/" data-href="https://redis.io/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Redis</a> or <a href="https://www.memcached.org/" data-href="https://www.memcached.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Memcached</a> to speed up the response times. The only change you’ll have to make is writing a new interface. There will be no need to update the business logic or anything else.</p><p name="55e6" id="55e6" class="graf graf--p graf-after--p">You could consider React and <a href="https://facebook.github.io/react-native/" data-href="https://facebook.github.io/react-native/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">React-Native</a> to be popular examples of this. They both use the same React component and React DOM interfaces, but they implement them differently. Even inside React Native there is an implementation for both IOS and Android. Multiple implementations allow you to write your logic once and execute it in multiple ways.</p><h3 name="91a2" id="91a2" class="graf graf--h3 graf-after--p">Now what?</h3><p name="33a3" id="33a3" class="graf graf--p graf-after--h3">Now that you’ve learned about dependency inversion and the open-closed principle, it’s time for you to go and apply it in your code. Don’t write any imports in the next module you write. Instead, allow it to accept an interface. In your tests, you’ll be able to avoid third-party libraries that mutate your dependencies! Then try to start identifying where common interfaces can be used. You’ll slowly but surely create a better application!</p><p name="095a" id="095a" class="graf graf--p graf-after--p graf--trailing">Please share in the comments about your experiences with these principles, and other ways you’ve avoided needing to use mocks and stubs in your tests.</p></div></div></section><section name="c7a3" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="0812" id="0812" class="graf graf--p graf--leading graf--trailing">Hi, I’m Justin Fuller. I’m so glad you read my post! I need to let you know that everything I’ve written here is my own opinion and is not intended to represent my employer in any way. All code samples are my own.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@justindanielfuller" class="p-author h-card">Justin Fuller</a> on <a href="https://medium.com/p/14e67ed6641a"><time class="dt-published" datetime="2018-10-23T00:56:13.587Z">October 23, 2018</time></a>.</p><p><a href="https://medium.com/@justindanielfuller/simply-javascript-a-straightforward-intro-to-mocking-stubbing-and-interfaces-14e67ed6641a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 8, 2018.</p></footer></article></body></html>