<article class="h-entry">
  <header>
  <h1 class="p-name">How writing tests can make you a faster and more productive developer</h1>
  </header>
  <section data-field="subtitle" class="p-summary">
  Most of us have heard of “writer’s block”, but have you heard of “developer’s block”? Just like a writer, a software developer can sit…
  </section>
  <section data-field="body" class="e-content">
  <section name="4370" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="df00" id="df00" class="graf graf--h3 graf--leading graf--title">How writing tests can make you a faster and more productive developer</h3><figure name="8af5" id="8af5" class="graf graf--figure graf-after--h3"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 543px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 77.60000000000001%;"></div><img class="graf-image" data-image-id="0*r5HIxulX8ruUZDaT" data-width="1000" data-height="776" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*r5HIxulX8ruUZDaT"></div></figure><p name="cba2" id="cba2" class="graf graf--p graf-after--figure">Most of us have heard of “writer’s block”, but have you heard of “developer’s block”? Just like a writer, a software developer can sit staring at a screen, not knowing where to begin. Sometimes that blank screen can be too intimidating and the code just doesn’t come to you.</p><p name="1e75" id="1e75" class="graf graf--p graf-after--p">So what do you do? Do you just take a coffee break, come back an hour later and hope you figure it out then? Maybe you can go talk to your coworkers, joke around for a bit, and put off getting that code working. Don’t worry, future you can deal with this problem! (You never really liked them all that much anyways.)</p><p name="0f6c" id="0f6c" class="graf graf--p graf-after--p">Instead of struggling to bring that code out of nowhere, there is a simple way to trick your mind into getting started. A writer can overcome this problem by starting with an outline and filling it in. A developer can begin by writing tests!</p><p name="c9a2" id="c9a2" class="graf graf--p graf-after--p">You do this by using tests as an outline. You can break your code up into tiny chunks, and this will redirect your focus away from the big problem and on to making a single test pass. Since you’ve broken up your problem into small pieces, each piece will be easier to understand. Eventually when you need to refactor you’ll quickly be alerted when a test breaks!</p><h4 name="ded0" id="ded0" class="graf graf--h4 graf-after--p">How To Use Tests</h4><p name="edfe" id="edfe" class="graf graf--p graf-after--h4">It’s actually pretty easy to write tests. Unfortunately it’s also pretty easy to write bad tests.</p><p name="0717" id="0717" class="graf graf--p graf-after--p">Bad tests take a long time to write. They also take a long time to run. Have you ever spent five minutes waiting for one hundred tests to run? I have! Bad tests break even if the input and output stays the same. Running them is hard — you have to look up the command or commands every time. Writing them is harder. You spend more time reading the testing library documentation than you do writing your own code.</p><p name="1963" id="1963" class="graf graf--p graf-after--p">In order for tests to allow you to write code faster, you must first know how to write good tests. In the following sections, I’m going to outline how to use tests in a way that will let you code much more efficiently.</p><h4 name="259f" id="259f" class="graf graf--h4 graf-after--p">Red Green Refactor 🚦</h4><p name="2fdf" id="2fdf" class="graf graf--p graf-after--h4">Efficient coding means knowing when your code does what you want. It also means you need to be alerted as soon as you’ve broken something.</p><p name="3db2" id="3db2" class="graf graf--p graf-after--p">There are two goals of red green refactor.</p><p name="6259" id="6259" class="graf graf--p graf-after--p">First, the tests should break when something goes wrong. Passing tests aren’t good enough if they don’t fail when the wrong things happen. The code <code class="markup--code markup--p-code">assert(true)</code> will always pass, but it will also always be useless!</p><p name="da8f" id="da8f" class="graf graf--p graf-after--p">Second, the tests should fail until your code does what you expect. This allows you to immediately know if you’ve written your code correctly.</p><p name="765d" id="765d" class="graf graf--p graf-after--p">Red green refactor says you should write code in the following order:</p><ol class="postList"><li name="64d5" id="64d5" class="graf graf--li graf-after--p">Write your test, it should fail.</li><li name="4430" id="4430" class="graf graf--li graf-after--li">Write only enough code to make your test pass (and not a single keystroke more!)</li><li name="d8a0" id="d8a0" class="graf graf--li graf-after--li">Refactor any existing code to make it more readable, performant, etc., but do not change or add any functionality. Your tests should still pass!</li></ol><p name="8a12" id="8a12" class="graf graf--p graf-after--li">You repeat this process continually until you have your final working product.</p><p name="3a4a" id="3a4a" class="graf graf--p graf-after--p">Beginning with a failing test is very important. It means that you’ve validated that the existing code does not do something. When you write your code and the tests passes, you’ve now validated that it works they way you expect it to.</p><p name="bf81" id="bf81" class="graf graf--p graf-after--p">If instead you started with a passing test, how would you know your test fails without your added code?</p><p name="8abc" id="8abc" class="graf graf--p graf-after--p">Many of you know this already, but might avoid “red green refactor” because it seems like it would take longer to write code this way. Instead I’ve found that it makes me write code faster.</p><p name="d630" id="d630" class="graf graf--p graf-after--p">The quick reward cycle for your effort is going to keep you excited about your work. No longer will you write code for minutes or hours only to despair when it doesn’t work once you finally execute it!</p><p name="6741" id="6741" class="graf graf--p graf-after--p">You will also know immediately if your code does what you expect. You will know immediately when you break existing functionality. No more waiting. No more frustration.</p><h4 name="c960" id="c960" class="graf graf--h4 graf-after--p">Don’t write any logic without a failing test</h4><p name="b9d3" id="b9d3" class="graf graf--p graf-after--h4">So how do you get started? You should start with a failing test, but what does that look like? It’s as simple as:</p><figure name="f651" id="f651" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/JustinDFuller/2dfaa243628c0294ee8663bb563beaab.js"></script></figure><p name="e483" id="e483" class="graf graf--p graf-after--figure">You can see that I’ve taken “don’t write any logic without a failing test” seriously here! The function has neither been created nor exported. The test fails as expected.</p><p name="e485" id="e485" class="graf graf--p graf-after--p">So how does this make you write code faster? Well, two things are happening here.</p><p name="0644" id="0644" class="graf graf--p graf-after--p">First, if you’re struggling to get started, this helps you to overcome your mental block by forcing you to begin doing <em class="markup--em markup--p-em">something. </em>I believe that just like in Newton’s law of motion — an object in motion stays in motion — a developer writing code tends to continue writing code.</p><p name="0875" id="0875" class="graf graf--p graf-after--p">Second, and most importantly, when you follow this rule your code will have the huge advantage of <em class="markup--em markup--p-em">only</em> doing what you’ve verified that it does. You are far less likely to have any surprises down the road because your test suite automatically verifies every character of your code.</p><p name="ac6b" id="ac6b" class="graf graf--p graf-after--p">Not only does it verify your code, but by writing the test first you are creating a road map for what you want your code to do! That road map, just like the writer’s outline mentioned before, lets you easily fill in the blanks.</p><figure name="a76e" id="a76e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/JustinDFuller/24724c6fcef4d6f3ab83743a8b5b4a6e.js"></script></figure><p name="d6f5" id="d6f5" class="graf graf--p graf-after--figure">This rule can be difficult to follow sometimes. In the code block above you should see that I returned <code class="markup--code markup--p-code">callback</code> but never tested the return value of <code class="markup--code markup--p-code">myFunction</code>. It’s very easy to forget to test something this small, and code coverage reporters don’t help you find it.</p><p name="9d31" id="9d31" class="graf graf--p graf-after--p">The more I practice this rule, the easier it becomes to avoid this, but it will always require constant vigilance and discipline.</p><h4 name="1598" id="1598" class="graf graf--h4 graf-after--p">Fast tests</h4><p name="52d3" id="52d3" class="graf graf--p graf-after--h4">Nothing stops a developer from writing tests quite like a slow test suite. The only thing worse is one that’s difficult to run at all!</p><p name="2475" id="2475" class="graf graf--p graf-after--p">Your goal should be to run thousands of tests in only a few seconds. This should be the case for most mid-tier and higher development machines.</p><p name="e6f9" id="e6f9" class="graf graf--p graf-after--p">To accomplish fast tests you will need a few things, in this order.</p><ol class="postList"><li name="d349" id="d349" class="graf graf--li graf-after--p">Your code should be fast.</li><li name="af90" id="af90" class="graf graf--li graf-after--li">Your unit tests should be isolated from expensive IO (Input and Output).</li><li name="77c5" id="77c5" class="graf graf--li graf-after--li">A fast test runner</li><li name="c713" id="c713" class="graf graf--li graf-after--li">A lightweight assertion library</li></ol><p name="1b4c" id="1b4c" class="graf graf--p graf-after--li">It doesn’t matter how good your test runner is, if your code is slow, your tests will be slow! If your unit tests make real HTTP requests or run actual SQL queries, your tests will be too slow!</p><p name="ce7f" id="ce7f" class="graf graf--p graf-after--p">Integration and regression tests can be expected to take slightly longer to run. That’s where you would perform real requests to the network, database, or file system. They should live in separate commands and test files in order to keep your unit tests fast.</p><h4 name="b29b" id="b29b" class="graf graf--h4 graf-after--p">Simple tests</h4><p name="c08a" id="c08a" class="graf graf--p graf-after--h4">Tests only make you write code faster when you can write your tests quickly. You can only write tests quickly if they are simple.</p><p name="1837" id="1837" class="graf graf--p graf-after--p">There should be no complicated commands to run — just <code class="markup--code markup--p-code">npm test</code> or something like <code class="markup--code markup--p-code">npm run test:coverage</code> for code coverage reports.</p><p name="ef9d" id="ef9d" class="graf graf--p graf-after--p">There should be no complicated API — just <code class="markup--code markup--p-code">assert(value)</code> or <code class="markup--code markup--p-code">assert.equal(expected, actual)</code>. Many of us have struggled with complicated assertion libraries where you <code class="markup--code markup--p-code">chain.every.word.to.make.a.sentence()</code>. If you’re like me you end up spending more time reading the docs than writing your tests.</p><p name="85f9" id="85f9" class="graf graf--p graf-after--p">You should avoid test hooks that set up and tear down your tests. Test runner functions like <code class="markup--code markup--p-code">before()</code> <code class="markup--code markup--p-code">after()</code> <code class="markup--code markup--p-code">beforeEach()</code> and <code class="markup--code markup--p-code">afterEach()</code> should be avoided because it encourages your tests to share state. This could lead to unpredictable tests because of that shared state. Instead you should just have a setup function or functions that return anything you need for your tests.</p><h4 name="d52a" id="d52a" class="graf graf--h4 graf-after--p">Use Snippets</h4><p name="2f0a" id="2f0a" class="graf graf--p graf-after--h4">There are certain tests that you will write over and over. Your test runner has a specific way of writing a test. You’ll likely have the same imports for many of your tests. Every single one of these things can be written more quickly with a snippet!</p><p name="bf40" id="bf40" class="graf graf--p graf-after--p">Your favorite code editor will have support for snippets. It doesn’t matter if you use a full IDE or a simple editor like vim. You can easily make snippets.</p><figure name="f664" id="f664" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/JustinDFuller/288eef9d311631c06cc0e06be90a6315.js"></script></figure><p name="bbf6" id="bbf6" class="graf graf--p graf-after--figure">I prefer to use Ava for my tests. The above snippet creates an entire basic test whenever I start a new test file using Visual Studio Code. You can see that <code class="markup--code markup--p-code">${1}</code> is included for the variable parts of the snippet. VScode allows me to tab through these, which I can usually do in a few seconds, and I have my first test ready!</p><p name="1595" id="1595" class="graf graf--p graf-after--p">You can do the same thing for mocha or any other test runner. I recommend making snippets for all the common tests that you create. Whenever you’ve repeated yourself a couple times — take a break and make a snippet!</p><h4 name="6070" id="6070" class="graf graf--h4 graf-after--p">Avoid mocking</h4><p name="cfba" id="cfba" class="graf graf--p graf-after--h4">While I suggest that you don’t make fun of people — that’s not quite what I’m talking about here!</p><p name="d8d3" id="d8d3" class="graf graf--p graf-after--p">It’s very common to use a library like <a href="http://sinonjs.org" data-href="http://sinonjs.org" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">sinon</a> or <a href="https://github.com/thlorenz/proxyquire" data-href="https://github.com/thlorenz/proxyquire" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">proxyquire</a> to change how dependency modules work. Usually we use them to isolate your code from expensive operations like an HTTP request, reading from a database, or operating on the file system.</p><p name="b9ac" id="b9ac" class="graf graf--p graf-after--p">I’ve stopped using these libraries because I believe there is a better way! Instead you can construct your modules to accept an interface of dependencies. Here’s what it looks like:</p><figure name="a6a1" id="a6a1" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/JustinDFuller/18e1516cc0fe6b2e0c5b9535966b7bb0.js"></script></figure><p name="0980" id="0980" class="graf graf--p graf-after--figure">Now you don’t need <code class="markup--code markup--p-code">proxyquire</code> or <code class="markup--code markup--p-code">sinon</code> or anything to change what the <code class="markup--code markup--p-code">fs</code> module does! You can provide that directly from your tests. So you don’t have to learn the <code class="markup--code markup--p-code">sinon</code> or <code class="markup--code markup--p-code">proxyquire</code> API, you don’t have to remember to call <code class="markup--code markup--p-code">restore()</code> on stubbed functions. Your tests are now simpler and easier and you can continue to write code faster than ever!</p><h3 name="6455" id="6455" class="graf graf--h3 graf-after--p">Wrapping up</h3><p name="631a" id="631a" class="graf graf--p graf-after--h3">By following these simple rules you should find that your tests allow you to write faster and more predictable code. You will be alerted more quickly when you break something. Most importantly you’ll be forced to plan out your code before you write it!</p><p name="4875" id="4875" class="graf graf--p graf-after--p">I hope that you see the benefits to developing like this. Like any change it won’t be easy right away, but with time and practice this will all feel natural. In fact you might eventually find that it feels unnatural and uncomfortable to write untested code!</p><p name="8e59" id="8e59" class="graf graf--p graf-after--p">Here’s a quick summary:</p><ul class="postList"><li name="7c6e" id="7c6e" class="graf graf--li graf-after--p">Red, Green, Refactor</li><li name="631b" id="631b" class="graf graf--li graf-after--li">Don’t write untested code</li><li name="b4e9" id="b4e9" class="graf graf--li graf-after--li">Keep your tests fast</li><li name="3a45" id="3a45" class="graf graf--li graf-after--li">Keep your tests simple</li><li name="f2a8" id="f2a8" class="graf graf--li graf-after--li">Use snippets</li><li name="e465" id="e465" class="graf graf--li graf-after--li">Avoid mocking</li></ul><p name="b542" id="b542" class="graf graf--p graf-after--li graf--trailing">Please share in the comments your experiences with testing your code. Have you been able to leverage your tests to deliver your product more quickly?</p></div></div></section><section name="3a62" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="e147" id="e147" class="graf graf--p graf--leading">Hi, I’m Justin Fuller. I’m so glad you read my post! I need to let you know that everything I’ve written here is my own opinion and is not intended to represent my employer in <em class="markup--em markup--p-em">any</em> way. All code samples are my own, and are completely unrelated to Bank Of America’s code.</p><p name="5c8a" id="5c8a" class="graf graf--p graf-after--p graf--trailing">I’d also love to hear from you, please feel free to connect with me on <a href="https://www.linkedin.com/in/justin-fuller-8726b2b1/" data-href="https://www.linkedin.com/in/justin-fuller-8726b2b1/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">LinkedIn</a>, <a href="https://github.com/justindfuller" data-href="https://github.com/justindfuller" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Github</a>, or <a href="https://medium.com/@justindanielfuller" data-href="https://medium.com/@justindanielfuller" class="markup--anchor markup--p-anchor" target="_blank">Medium</a>. Thanks again for reading!</p></div></div></section>
  </section>
  <footer><p>By <a href="https://medium.com/@justindanielfuller" class="p-author h-card">Justin Fuller</a> on <a href="https://medium.com/p/f3ad978e3872"><time class="dt-published" datetime="2018-10-17T22:51:09.190Z">October 17, 2018</time></a>.</p><p><a href="https://medium.com/@justindanielfuller/how-writing-tests-can-make-you-a-faster-and-more-productive-developer-f3ad978e3872" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 8, 2018.</p></footer></article>